

```javascript
HTTP2
    HTTP2中所有协议是小写字母，这点跟HTTP1不同。
    另外部分新增的协议用冒号开头，称之为 pseudo header name, 冒号只是为了作为特别的区分.带冒号的 header 头只有几个，其余都只是小写而已
```



![54E71A43FE434FD0B33F31F133475413](https://github.com/CHENJIAMIAN/Blog/assets/20126997/eff408d2-ada7-4e86-9037-7030fdab47f0)


```javascript
与HTTPS区别:
    安全|443

hash:线性散列算法(函数)：MD5, SHA1  
    //哈希表存储的是键值对,由hash函数生成
    //哈希函数(也叫消息摘要),是签名算法,将数据运算定长值,用于一致性验证
    //加盐:MD5(123456+'$1@Aa这就是盐')    
    函数类型:
        1、加法Hash
        2、位运算Hash
        3、乘法Hash
        4、除法Hash
        5、查表Hash
        6、混合Hash//各种常见的Hash算法，比方MD5、Tiger都属于这个范围。
    哈希表处理冲突: //为产生冲突的关键字寻找下一个哈希地址
        1.开放寻址法
        2.再散列法
        3.链地址法（拉链法）
            //HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的
        4.建立一个公共溢出区
    
    
对称:加密和解密都使用同一个密钥,在现代没法再网络上安全地交换密钥，所以不够安全
    对称性加密算法：AES(32位),3DES(24位)

非对称: 由于加密和解密需要两个不同的密钥,比对称的好//也叫:公开密钥密码学（Public-key cryptography)    
    非对称性加密算法：RSA,DSA,ECC
    //在计算上相当复杂，性能欠佳,实际情况下，往往通过非对称加密来随机创建临时的对称秘钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据。

/HTTPS过程/ 重点
    1.SSL/TLS(非对称加密)  //3个随机数生成【会话密钥】 //直接交换随机数,再用 公私钥 交换 第3个 随机数
        客户端:  1TLS             | 2加密算法 | 3这是我的【随机字符串】
        服务器:  1SSL证书含公钥    | 2加密算法 | 3这是我的【随机字符串】
        客户端(对服务器进行身份验证)：我问机构了,你的SSL证书是真的, 这是我的另一个用你【SSL证书上的|公钥】加密的【“premaster机密随机字符串”】
        服务器:我用我【SSL证书上的|私钥】解密获得【“premaster机密”】了
        /创建的会话密钥：客户端和服务器均从【1客户端随机 2服务器随机 3premaster机密随机字符串】生成【会话密钥】。他们应该得出相同的结果。/
        //如下：
    2.会话加密(对称加密)
        客户端：【会话密钥】加密了一条消息,你看能不能解开
        服务器：我用【会话密钥】解开了,我们以后就用【会话密钥】


网站如何获得SSL证书(包含[公钥][私钥], 放在服务器): //防止”中间人“攻击
    //SSL证书是数字证书的一种，类似于护照本。    //因为私钥存在Web服务器上，也称为SSL服务器证书
    //网站获取SSL证书，必须要提供相关真实资料给权威的证书颁发机构进行SSL认证，经过彻底验证的 真实网站才有资格获取SSL证书。

CA(认证中心)是负责签发证书、认证证书、管理已颁发证书的机关, 拥有一个证书（内含公钥和私钥）
 .pem //证书编码格式,包含
    .CRT //即 certificate的缩写，即证书。   
    .CSR //是Certificate Signing Request的缩写，即证书签名请求，这不是证书，可以简单理解成【公钥】，生成证书时要把这个提交给权威的证书颁发机构。
.KEY //通常指私钥。


RSA加密解密：每一方都有自己的保险柜(公钥)跟钥匙(私钥),//公钥加密私钥解密还是公钥解密私钥加密其实都是一样的,只是相对的说法
    目的:双方互相拥有对方的保险柜(公钥),用对方的保险柜(公钥)加密, 让对方用自己的钥匙(私钥)解密
        0.A拥有A公钥A私钥,B拥有B公钥B私钥
        1.B 发【B公钥】给 A//[B公钥]可能被截获,然而别人截获没什么用,别人没有[B私钥]
        2.A 发【A公钥】给 B
            或//A 发【B公钥加密过的A公钥】给 B (更安全)
            //为什么[A公钥]不直接发过去而要发经过加密的【B公钥加密过的A公钥】,因为加密后别人截获【B公钥加密过的A公钥】也用不了,确保[A公钥]只有B拥有
        3.B 得到【A公钥】//B(有【B公钥加密过的A公钥】) => 用【B私钥】解开  => 得到【A公钥】
        4.此时：双方互相拥有对方的保险柜(公钥)
        5.下次: 要发送信息给对方,就用对方的保险柜(公钥)加密, 让对方用自己的钥匙(私钥)解密
    
RSA数字签名-俗称加签验签： 私钥加签，公钥验签。
    目的: 公钥是可能给发送给其他系统的，你无法得知是哪个系统给你传输的这个数据，所以就有了签名这一说。
        甲系统（有乙公钥）
            1 甲私钥对信息加密，得到 甲签名字段
            2 使用乙公钥加密 （信息+甲签名字段），传给乙系统。
        
        乙系统（有甲公钥）
            1 拿到数据后，先使用乙私钥解密数据，得到 （信息+甲签名字段）
            3 然后甲公钥解密的 甲签名字段 得到 信息 与 信息 进行对比，这一步叫做验签
            4 如果相等则代表此数据时 由甲方传来 且数据没有被篡改。     
```



